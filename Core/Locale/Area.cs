using Hedron.Core.Container;
using Hedron.Core.Entities.Base;
using Hedron.Core.Entities.Living;
using Hedron.Core.Entities.Properties;
using Hedron.Core.Factory;
using Hedron.Core.System;
using Hedron.Core.System.Exceptions.Locale;
using Hedron.Data;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Hedron.Core.Locale
{
	public class Area : CacheableObject, ICopyableObject<Area>, IEntity //, ILocale
	{
		/// <summary>
		/// The room list for the area
		/// </summary>
		[JsonConverter(typeof(EntityContainerPropertyConverter))]
		[JsonProperty]
		public EntityContainer Rooms { get; protected set; } = new EntityContainer();

		/// <summary>
		/// The tier for this area
		/// </summary>
		[JsonProperty]
		public Tier Tier { get; private set; } = new Tier();

		/// <summary>
		/// The name of this area
		/// </summary>
		[JsonProperty]
		public string Name { get; set; }

		/// <summary>
		/// A list of randomly generated prototype items associated with this area
		/// </summary>
		[JsonConverter(typeof(EntityContainerPropertyConverter))]
		[JsonProperty]
		public EntityContainer AutogeneratedPrototypeItems { get; protected set; } = new EntityContainer();

		/// <summary>
		/// A list of randomly generated prototype mobs associated with this area
		/// </summary>
		[JsonConverter(typeof(EntityContainerPropertyConverter))]
		[JsonProperty]
		public EntityContainer AutogeneratedPrototypeMobs { get; protected set; } = new EntityContainer();

		/// <summary>
		/// The rate of respawning in ticks
		/// </summary>
		/// <remarks>A value of </remarks>
		[JsonProperty]
		public int RespawnRate { get; set; } = Constants.AREA_MANUAL_RESPAWN;

		[JsonProperty]
		public string ShortDescription { get; set; }

		[JsonProperty]
		public string LongDescription { get; set; }

		/// <summary>
		/// Creates a new area. Must be added to cache.
		/// </summary>
		public Area() : base()
		{
			Name = "[name]";
		}

		/// <summary>
		/// Respawns the area
		/// </summary>
		/// TODO: Improve systems for conditional respawning, e.g. players in or out of the area and when they were last in the area
		public void Respawn()
		{
			if (CacheType == CacheType.Prototype)
				return;

			var allRooms = Rooms.GetAllEntities<Room>();

			var protoMobQuantities = new Dictionary<uint, int>();
			var protoItemQuantities = new Dictionary<uint, int>();
			var protoShopQuantities = new Dictionary<uint, int>();
			var protoStorageQuantities = new Dictionary<uint, int>();

			var instanceMobQuantities = new Dictionary<uint, int>();
			var instanceItemQuantities = new Dictionary<uint, int>();
			var instanceShopQuantities = new Dictionary<uint, int>();
			var instanceStorageQuantities = new Dictionary<uint, int>();

			// Build quantity dictionaries
			foreach (var roomID in allRooms)
			{
				var protoRoom = DataAccess.Get<Room>(roomID, CacheType.Prototype);
				var instanceRoom = DataAccess.Get<Room>(roomID, CacheType.Instance);

				Dictionary<uint, int> roomProtoMobQuantities = protoRoom?.Animates.CountAllEntitiesByPrototypeID<Mob>() ?? new Dictionary<uint, int>();
				Dictionary<uint, int> roomProtoItemQuantities = protoRoom?.Items.CountAllEntitiesByPrototypeID<EntityInanimate>() ?? new Dictionary<uint, int>();
				Dictionary<uint, int> roomProtoShopQuantities = protoRoom?.ShopItems.CountAllEntitiesByPrototypeID<EntityInanimate>() ?? new Dictionary<uint, int>();
				Dictionary<uint, int> roomProtoStorageQuantities = protoRoom?.StorageItems.CountAllEntitiesByPrototypeID<Storage>() ?? new Dictionary<uint, int>();

				Dictionary<uint, int> roomInstanceMobQuantities = instanceRoom?.Animates.CountAllEntitiesByPrototypeID<Mob>() ?? new Dictionary<uint, int>();
				Dictionary<uint, int> roomInstanceItemQuantities = instanceRoom?.Items.CountAllEntitiesByPrototypeID<EntityInanimate>() ?? new Dictionary<uint, int>();
				Dictionary<uint, int> roomInstanceShopQuantities = instanceRoom?.ShopItems.CountAllEntitiesByPrototypeID<EntityInanimate>() ?? new Dictionary<uint, int>();
				Dictionary<uint, int> roomInstanceStorageQuantities = instanceRoom?.StorageItems.CountAllEntitiesByPrototypeID<Storage>() ?? new Dictionary<uint, int>();

				foreach (var kvp in roomProtoMobQuantities)
				{
					if (protoMobQuantities.ContainsKey(kvp.Key))
						protoMobQuantities[kvp.Key] += kvp.Value;
					else
						protoMobQuantities.Add(kvp.Key, kvp.Value);
				}

				foreach (var kvp in roomProtoItemQuantities)
				{
					if (protoItemQuantities.ContainsKey(kvp.Key))
						protoItemQuantities[kvp.Key] += kvp.Value;
					else
						protoItemQuantities.Add(kvp.Key, kvp.Value);
				}

				foreach (var kvp in roomProtoShopQuantities)
				{
					if (protoShopQuantities.ContainsKey(kvp.Key))
						protoShopQuantities[kvp.Key] += kvp.Value;
					else
						protoShopQuantities.Add(kvp.Key, kvp.Value);
				}

				foreach (var kvp in roomProtoStorageQuantities)
				{
					if (protoStorageQuantities.ContainsKey(kvp.Key))
						protoStorageQuantities[kvp.Key] += kvp.Value;
					else
						protoStorageQuantities.Add(kvp.Key, kvp.Value);
				}

				foreach (var kvp in roomInstanceMobQuantities)
				{
					if (instanceMobQuantities.ContainsKey(kvp.Key))
						instanceMobQuantities[kvp.Key] += kvp.Value;
					else
						instanceMobQuantities.Add(kvp.Key, kvp.Value);
				}

				foreach (var kvp in roomInstanceItemQuantities)
				{
					if (instanceItemQuantities.ContainsKey(kvp.Key))
						instanceItemQuantities[kvp.Key] += kvp.Value;
					else
						instanceItemQuantities.Add(kvp.Key, kvp.Value);
				}

				foreach (var kvp in roomInstanceShopQuantities)
				{
					if (instanceShopQuantities.ContainsKey(kvp.Key))
						instanceShopQuantities[kvp.Key] += kvp.Value;
					else
						instanceShopQuantities.Add(kvp.Key, kvp.Value);
				}

				foreach (var kvp in roomInstanceStorageQuantities)
				{
					if (instanceStorageQuantities.ContainsKey(kvp.Key))
						instanceStorageQuantities[kvp.Key] += kvp.Value;
					else
						instanceStorageQuantities.Add(kvp.Key, kvp.Value);
				}
			}

			// Spawn missing mobs
			foreach (var kvp in protoMobQuantities)
			{
				int difference = 0;

				if (instanceMobQuantities.ContainsKey(kvp.Key))
					difference = kvp.Value - instanceMobQuantities[kvp.Key];
				else
					difference = kvp.Value;

				if (difference > 0)
				{
					var rooms = GetAllRoomsContainingEntityOfPrototype<Mob>(kvp.Key);
					for (var i = 0; i < difference; i++)
					{
						var mob = DataAccess.Get<Mob>(kvp.Key, CacheType.Prototype)?.SpawnAsObject<Mob>(true, (uint)rooms[World.Random.Next(rooms.Count - 1)].Instance);
						if (mob != null)
							Logger.Info(nameof(Area), nameof(Respawn), $"Completed respawning {mob.Name} ({mob.Prototype}) in area {Name} ({Instance}).");
						else
							Logger.Bug(nameof(Area), nameof(Respawn), $"Mob not found for respawning in area {Name} ({Instance}).");
					}
				}
			}

			// Spawn missing items
			foreach (var kvp in protoItemQuantities)
			{
				int difference = 0;

				if (instanceItemQuantities.ContainsKey(kvp.Key))
					difference = kvp.Value - instanceItemQuantities[kvp.Key];
				else
					difference = kvp.Value;

				if (difference > 0)
				{
					var rooms = GetAllRoomsContainingEntityOfPrototype<EntityInanimate>(kvp.Key);
					for (var i = 0; i < difference; i++)
					{
						var item = DataAccess.Get<EntityInanimate>(kvp.Key, CacheType.Prototype)?.SpawnAsObject<EntityInanimate>(true, (uint)rooms[World.Random.Next(rooms.Count - 1)].Instance);
						if (item != null)
							Logger.Info(nameof(Area), nameof(Respawn), $"Completed respawning {item.Name} ({item.Prototype}) in area {Name} ({Instance}).");
						else
							Logger.Bug(nameof(Area), nameof(Respawn), $"Item not found for respawning in area {Name} ({Instance}).");
					}
				}
			}

		}

		/// <summary>
		/// Provides a list of rooms in this area that contain a given entity
		/// </summary>
		/// <param name="prototypeID">The prototype ID of the entity</param>
		/// <returns>A list of room objects that contain the entity</returns>
		/// <remarks>The list may contain duplicates if a room contains the entity more than once. This is by design
		/// so, for example, as to allow the Respawn function to randomly pick from the list; if a room contains an entity once, and another
		/// room contains the entity 9 times, there will be a 9/10 chance the entity respawns in the room with 9 entities.</remarks>
		public List<Room> GetAllRoomsContainingEntityOfPrototype<T>(uint prototypeID) where T: IEntity
		{
			List<Room> roomsContainingEntity = new List<Room>();

			foreach (var rID in Rooms.GetAllEntities())
			{
				var room = DataAccess.Get<Room>(rID, CacheType);

				if (room != null)
				{
					List<T> entities;

					if (room.CacheType == CacheType.Instance)
						entities = DataAccess.Get<Room>(room.Prototype, CacheType.Prototype)?.GetAllEntities<T>();
					else
						entities = room.GetAllEntities<T>();

					foreach (var e in entities)
						if (e.Prototype == prototypeID)
							roomsContainingEntity.Add(room);
				}
			}

			return roomsContainingEntity;
		}

		/// <summary>
		/// Retrieves all living entities contained within this area's rooms
		/// </summary>
		/// <typeparam name="T">The type of <see cref="EntityAnimate"/> to retrieve.</typeparam>
		/// <returns>A list of all <typeparamref name="T"/></returns>
		public List<T> GetAllLivingEntities<T>() where T: EntityAnimate
		{
			var entities = new List<T>();
			foreach (var room in Rooms.GetAllEntitiesAsObjects<Room>())
			{
				var e = room.Animates.GetAllEntitiesAsObjects<T>();
				entities.AddRange(e);
			}
			return entities;
		}

		/// <summary>
		/// Retrieves all living entities contained within this area's rooms
		/// </summary>
		/// <typeparam name="T">The type of <see cref="EntityAnimate"/> to retrieve.</typeparam>
		/// <returns>A list of all <typeparamref name="T"/></returns>
		public List<T> GetAllInanimateEntities<T>() where T : EntityInanimate
		{
			var entities = new List<T>();
			foreach (var room in Rooms.GetAllEntitiesAsObjects<Room>())
			{
				var e = room.Items.GetAllEntitiesAsObjects<T>();
				entities.AddRange(e);
			}
			return entities;
		}

		/// <summary>
		/// Creates a new area and adds it to the Prototype cache
		/// </summary>
		/// <param name="parentID">The parent ID of the world to add this area to.</param>
		/// <returns>The new prototype room</returns>
		public static Area NewPrototype(uint parentID)
		{
			var newArea = new Area();
			newArea.Rooms.CacheType = CacheType.Prototype;
			newArea.AutogeneratedPrototypeItems.CacheType = CacheType.Prototype;
			newArea.AutogeneratedPrototypeMobs.CacheType = CacheType.Prototype;

			var world = DataAccess.Get<World>(parentID, CacheType.Prototype);

			if (world == null)
				throw new LocaleException($"Failed to locate parent ID ({parentID}) when generating new area protoype.");

			DataAccess.Add<Area>(newArea, CacheType.Prototype);

			newArea.Rooms.PrototypeParents.Add((uint)newArea.Prototype);
			newArea.AutogeneratedPrototypeItems.PrototypeParents.Add((uint)newArea.Prototype);
			newArea.AutogeneratedPrototypeMobs.PrototypeParents.Add((uint)newArea.Prototype);

			DataAccess.Add<EntityContainer>(newArea.Rooms, CacheType.Prototype);
			DataAccess.Add<EntityContainer>(newArea.AutogeneratedPrototypeItems, CacheType.Prototype);
			DataAccess.Add<EntityContainer>(newArea.AutogeneratedPrototypeMobs, CacheType.Prototype);

			world.Areas.AddEntity(newArea.Prototype, newArea, true);

			DataPersistence.SaveObject(newArea);
			return newArea;
		}

		/// <summary>
		/// Creates a new area and adds it to the Instance cache
		/// </summary>
		/// <param name="withPrototype">Whether to also create a backing prototype. If so, the Prototype World will also have the
		/// prototype area added.</param>
		/// <param name="parentID">The parent world Instance ID.</param>
		/// <returns>The new instanced area</returns>
		public static Area NewInstance(bool withPrototype, uint parentID)
		{
			Area newArea;

			if (withPrototype)
			{
				var instanceWorld = DataAccess.Get<World>(parentID, CacheType.Instance);
				if (instanceWorld == null)
					throw new LocaleException($"{nameof(Area)}.{nameof(NewInstance)}: parentID retrieved null instance world.");

				var protoWorld = DataAccess.Get<World>(instanceWorld.Prototype, CacheType.Prototype);
				if (protoWorld == null)
					throw new LocaleException($"{nameof(Area)}.{nameof(NewInstance)}: parentID retrieved null prototype world.");

				newArea = DataAccess.Get<Area>(NewPrototype((uint)protoWorld.Prototype).Spawn(false, parentID), CacheType.Instance);
			}
			else
			{
				var world = DataAccess.Get<World>(parentID, CacheType.Instance);
				if (world == null)
					throw new LocaleException($"{nameof(Room)}.{nameof(NewInstance)}: parentID retrieved null instance world.");

				newArea = DataAccess.Get<Area>(DataAccess.Add<Area>(new Area(), CacheType.Instance), CacheType.Instance);
				DataAccess.Add<EntityContainer>(newArea.Rooms, CacheType.Instance);
				DataAccess.Add<EntityContainer>(newArea.AutogeneratedPrototypeItems, CacheType.Instance);
				DataAccess.Add<EntityContainer>(newArea.AutogeneratedPrototypeMobs, CacheType.Instance);

				world.Areas.AddEntity(newArea.Instance, newArea, false);
			}

			newArea.Rooms.InstanceParent = newArea.Instance;
			newArea.Rooms.InstanceParent = newArea.Instance;
			newArea.Rooms.InstanceParent = newArea.Instance;
			return newArea;
		}

		/// <summary>
		/// Creates a new area. Must be added to cache.
		/// </summary>
		/// <param name="tier">The tier level</param>
		public Area(int tier) : this()
		{
			Tier.Level = tier;
		}

		/// <summary>
		/// Spawns an instance of the area from prototype and adds it to the cache.
		/// </summary>
		/// <param name="withEntities">Whether to also spawn contained rooms</param>
		/// <param name="parent">The parent instance ID</param>
		/// <returns>The spawned area. Will return null if the method is called from an instanced object.</returns>
		/// <remarks>Exits will all be null and must be fixed from prototype. Parent cannot be null.</remarks>
		public override T SpawnAsObject<T>(bool withEntities, uint parent)
		{
			return DataAccess.Get<T>(Spawn(withEntities, parent), CacheType.Instance);
		}

		/// <summary>
		/// Spawns an instance of the area from prototype and adds it to the cache.
		/// </summary>
		/// <param name="withEntities">Whether to also spawn contained rooms.</param>
		/// <param name="parent">The parent instance ID</param>
		/// <returns>The instance ID of the spawned area. Will return null if the method is called from an instanced object.</returns>
		/// <remarks>Does not fix spawned instance rooms' exits.</remarks>
		public override uint? Spawn(bool withEntities, uint parent)
		{
			if (CacheType != CacheType.Prototype)
				return null;

			var parentContainer = DataAccess.Get<EntityContainer>(parent, CacheType.Instance);
			var parentWorld = DataAccess.Get<World>(parentContainer.InstanceParent, CacheType.Instance);

			if (parentContainer == null || parentWorld == null)
				throw new LocaleException("Parent cannot be null when spawning an area.");

			// Create new instance area and add to parent container
			var newArea = DataAccess.Get<Area>(DataAccess.Add<Area>(new Area(), CacheType.Instance), CacheType.Instance);
			parentWorld.Areas.AddEntity(newArea.Instance, newArea, false);

			Logger.Info(nameof(Area), nameof(Spawn), "Spawning area: " + Name + ": ProtoID=" + Prototype.ToString());

			// Set remaining properties
			newArea.Prototype = Prototype;
			CopyTo(newArea);

			// Spawn contained entities
			if (withEntities)
			{
				newArea.Rooms = Rooms.SpawnAsObject<EntityContainer>(!withEntities, (uint)newArea.Instance);
				foreach (var room in Rooms.GetAllEntitiesAsObjects<Room>())
					room.Spawn(withEntities, (uint)newArea.Rooms.Instance);
			}
			else
			{
				newArea.Rooms = Rooms.SpawnAsObject<EntityContainer>(!withEntities, (uint)newArea.Instance);
			}

			Logger.Info(nameof(Area), nameof(Spawn), "Finished spawning area.");

			return newArea.Instance;
		}

		/// <summary>
		/// Copies this area's properties to another area.
		/// </summary>
		/// <param name="area">The area to copy to.</param>
		/// <remarks>Doesn't copy IDs or cache type.</remarks>
		public void CopyTo(Area area)
		{
			Guard.ThrowIfNull(area, nameof(area));

			area.Name = Name;
			area.Tier.Level = Tier.Level;
			area.RespawnRate = RespawnRate;
		}

		/// <summary>
		/// Handles the ObjectDestroyed event. Only DataAccess should call this directly.
		/// </summary>
		/// <param name="source">The object raising the event</param>
		/// <param name="args">The generic event args</param>
		override protected void OnObjectDestroyed(object source, CacheObjectEventArgs args)
		{
			DataAccess.Remove<EntityContainer>(args.CacheType == CacheType.Instance ? Rooms.Instance : Rooms.Prototype, args.CacheType);
		}
	}
}