using Hedron.Core.Entities.Properties;
using Hedron.Data;
using Hedron.Core.Container;
using Hedron.Core.Factory;
using Hedron.Core.Locale;
using Hedron.Core.System;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Hedron.Core.Entities.Base
{
	/// <summary>
	/// Base entity class for common attributes
	/// </summary>
	public abstract class Entity : CacheableObject, ICopyableObject<Entity>, IEntity, IEffectObservable, IEntityChildOfRoom, IEntityChildOfArea
	{
		protected List<Effect> _effects = new List<Effect>();

		public event EventHandler<EffectEventArgs> EffectAdded;

		public event EventHandler<EffectEventArgs> EffectRemoved;

		/// <summary>
		/// The Effects on the entity
		/// </summary>
		public IReadOnlyCollection<Effect> Effects
		{
			get
			{
				return _effects.AsReadOnly();
			}
		}

		/// <summary>
		/// The name of the entity
		/// </summary>
		public string Name { get; set; } = "[name]";

		/// <summary>
		/// The Short Description of the entity
		/// </summary>
		public string ShortDescription { get; set; } = "[short]";

		/// <summary>
		/// The Long Description of the entity
		/// </summary>
		public string LongDescription { get; set; } = "[long]";

		/// <summary>
		/// The Tier of the entity
		/// </summary>
		public Tier Tier { get; protected set; } = new Tier();

		/// <summary>
		/// Whether this entity was automatically generated
		/// </summary>
		public bool WasAutoGenerated { get; set; }

		/// <summary>
		/// Default constructor
		/// </summary>
		public Entity() : base()
		{

		}

		/// <summary>
		/// Adds an Effect to the entity
		/// </summary>
		/// <param name="Effect">The Effect to add</param>
		/// <param name="stack">Whether to stack the Effect. If false, the Effect will overwrite any Effect(s) of the same name.</param>
		public virtual void AddEffect(Effect Effect, bool stack)
		{
			OnEffectAdded(new EffectEventArgs(Effect));
		}

		/// <summary>
		/// Invokes the EffectAdded event
		/// </summary>
		/// <param name="args">The event args</param>
		protected virtual void OnEffectAdded(EffectEventArgs args)
		{
			var handler = EffectAdded;
			if (handler != null)
				handler.Invoke(this, args);
		}

		/// <summary>
		/// Removes all Effects of the given name
		/// </summary>
		/// <param name="EffectName">The Effect name to remove</param>
		public void RemoveEffect(string EffectName)
		{
			var indexes = new List<int>();

			indexes = Enumerable.Range(0, _effects.Count)
				.Where(i => _effects[i].Name == EffectName)
				.ToList();

			for (var i = indexes.Count; i > 0; i--)
			{
				var EffectRemoved = _effects[i - 1];
				RemoveEffectAt(i - 1);
				OnEffectRemoved(new EffectEventArgs(EffectRemoved));
			}
		}

		/// <summary>
		/// Removes a specific Effect at the given index in Effects
		/// </summary>
		/// <param name="index">The index of the Effect to remove</param>
		public virtual void RemoveEffectAt(int index)
		{
			try
			{
				var EffectRemoved = _effects[index];
				_effects.RemoveAt(index);
				OnEffectRemoved(new EffectEventArgs(EffectRemoved));
			}
			catch
			{
				return;
			}
		}

		/// <summary>
		/// Removes all Effects from the entity
		/// </summary>
		public virtual void RemoveAllEffects()
		{
			for (var i = _effects.Count; i > 0; i--)
				RemoveEffectAt(i - 1);
		}

		public Room GetInstanceParentRoom()
		{
			if (CacheType != CacheType.Instance)
				return null;

			var parentContainer = DataAccess.Get<EntityContainer>(InstanceParent, CacheType.Instance);
			return DataAccess.Get<Room>(parentContainer?.InstanceParent, CacheType.Instance);
		}

		public List<Room> GetPrototypeParentRooms()
		{
			var rooms = new List<Room>();
			var proto = DataAccess.Get<Room>(Prototype, CacheType.Prototype);

			var parentContainers = DataAccess.GetMany<EntityContainer>(proto?.PrototypeParents, CacheType.Prototype);
			return DataAccess.GetMany<Room>(parentContainers.Select(r => r.Prototype).Cast<uint>().ToList(), CacheType.Prototype);
		}

		public Area GetInstanceParentArea()
		{
			if (CacheType != CacheType.Instance)
				return null;

			return GetInstanceParentRoom()?.GetInstanceParentArea();
		}

		public List<Area> GetPrototypeParentAreas()
		{
			var areas = new List<Area>();

			if (CacheType != CacheType.Prototype)
				return areas;

			var parentRooms = GetPrototypeParentRooms();
			foreach (var room in parentRooms)
			{
				var pAreas = room.GetPrototypeParentAreas();
				foreach (var a in pAreas)
					areas.Add(a);
			}

			return areas;
		}

		/// <summary>
		/// Invokes the EffectRemoved event
		/// </summary>
		/// <param name="args">The event args</param>
		protected virtual void OnEffectRemoved(EffectEventArgs args)
		{
			var handler = EffectRemoved;
			if (handler != null)
				handler.Invoke(this, args);
		}

		/// <summary>
		/// Override OnObjectDestroyed to ensure all Effects are removed upon entity deletion
		/// </summary>
		/// <param name="source"></param>
		/// <param name="args"></param>
		protected override void OnObjectDestroyed(object source, CacheObjectEventArgs args)
		{
			RemoveAllEffects();
			base.OnObjectDestroyed(source, args);
		}

		/// <summary>
		/// Copies this entity's properties to another entity.
		/// </summary>
		/// <param name="entity">The entity to copy to.</param>
		/// <remarks>Doesn't copy IDs, cache type, or IOHandler?./remarks>
		public virtual void CopyTo(Entity entity)
		{
			if (entity == null)
				return;

			entity.Name = Name;
			entity.LongDescription = LongDescription;
			entity.ShortDescription = ShortDescription;
			entity.Tier.Level = Tier.Level;
			entity.WasAutoGenerated = WasAutoGenerated;
		}
	}
}